<!doctype html><html lang><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="chrome=1"><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><title>How Does React V18's Concurrency Improve Performance? -</title><meta property="og:title" content="How does React v18&rsquo;s concurrency improve performance? - "><meta property="og:type" content="website"><meta property="og:description" content><meta property="og:url" content="https://ryanlmahan.com/blog/reactconcurrency/"><meta property="og:site_name" content><meta property="og:image" content="https://ryanlmahan.com/blog/reactconcurrency/api.png"><meta property="og:image" content="https://ryanlmahan.com/blog/reactconcurrency/blocking.png"><meta property="og:image" content="https://ryanlmahan.com/blog/reactconcurrency/click.png"><link rel="shortcut icon" href=/img/favicon.ico><link rel=stylesheet href=/css/main.min.8cdad1906a87a5bf6d8ea97d1ddb52cbb6b1ce4f9096e77708e06b57188f6346.css integrity="sha256-jNrRkGqHpb9tjql9HdtSy7axzk+Qlud3COBrVxiPY0Y=" crossorigin=anonymous media=screen><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0,securityLevel:"loose"})</script></head><body><section id=top class=section><div class="container hero"><h1 class="bold-title is-1">Ryan&rsquo;s Blog</h1></div><div class=section><div class=container><hr><nav class=navbar role=navigation aria-label="main navigation"><a role=button class=navbar-burger data-target=navMenu aria-label=menu aria-expanded=false><span aria-hidden=true></span>
<span aria-hidden=true></span>
<span aria-hidden=true></span></a><div class=navbar-menu id=navMenu><a class=navbar-item href=/>main</a>
<a class=navbar-item href=/#about>About Me</a>
<a class=navbar-item href=https://ryanlmahan.com/blog/>Back to Ryan's Blog</a>
<a class=navbar-item href=https://ryanlmahan.com/projects/>Projects</a>
<a class=navbar-item href=https://ryanlmahan.com/presentations/>Presentations</a>
<a class=navbar-item href=/#contact>Contact Me</a></div></nav><hr></div><div class=container><h2 class="title is-1 top-pad strong-post-title"><a href=https://ryanlmahan.com/blog/reactconcurrency/>How does React v18&rsquo;s concurrency improve performance?</a></h2><div class=post-data>Apr 4, 2022 |
4 minutes read</div><div class=blog-share>Share this:
<a class=twitter-share-button href="https://twitter.com/intent/tweet?text=How%20does%20React%20v18%26rsquo%3bs%20concurrency%20improve%20performance%3f%20https%3a%2f%2fryanlmahan.com%2fblog%2freactconcurrency%2f" onclick='return window.open(this.href,"twitter-share","width=550,height=235"),!1'><i class="fab fa-twitter"></i>
<span class=hidden>Twitter</span></a>
<a class=icon-facebook href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fryanlmahan.com%2fblog%2freactconcurrency%2f" onclick='return window.open(this.href,"facebook-share","width=580,height=296"),!1'><i class="fab fa-facebook-f"></i>
<span class=hidden>Facebook</span></a>
<a class=icon-linkedin href="https://www.linkedin.com/sharing/share-offsite/?url=https%3a%2f%2fryanlmahan.com%2fblog%2freactconcurrency%2f"><i class="fab fa-linkedin"></i>
<span class=hidden>LinkedIn</span></a></div><p>Tags:
<a href=/tags/react>react</a></p></div><div class="container markdown top-pad"><p>The React team has implemented concurrency on a single threaded V8 execution context. How does increased concurrency help when you only have one thread? Let&rsquo;s take a look at how Operating Systems developers were able to increase the performance of their hardware through the CPU scheduler.</p><p>First, if you haven&rsquo;t read the <a href=https://17.Reactjs.org/docs/concurrent-mode-intro.html>React team&rsquo;s writeup on their concurrency feature</a>, or <a href=https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react>their more recent React v18 updates</a> you should. They explain how they implemented it and how to use it.</p><h2 id=how-does-multithreading-increase-performance-on-a-single-core-cpu class=anchor-link><a href=#how-does-multithreading-increase-performance-on-a-single-core-cpu>How does multithreading increase performance on a single-core CPU?</a></h2><p>Operating systems have long used schedulers to more fairly allocate resources to the processes running within them. In a computer with one processor and execution context, multi-threading can be used to reduce blocking calls. For example, if we have a few threads running at once, and one makes an I/O call:</p><img alt="An I/O blocking call" width=66% src=blocking.png><p>In our blocking example, P<sub>1</sub> holds onto the CPU while the disk is fetching the data it needs. The computer is locked up. Nothing else can happen. If the user clicks, nothing. This is the fundamental problem with blocking calls, our CPU is sitting idle when it could be working.</p><p>This was fixed with scheduling processes. When a process made a request for I/O, it would be kicked off the CPU and placed in a waiting queue. This would allow the CPU to process some more data, refresh the user interface, or whatever it had ready to be run. Eventually, the I/O request returns, P<sub>1</sub> is scheduled again and continues its execution.</p><div style="margin-left:10%;margin-bottom:1em;background:#f0f0f0;border-left:2px solid #5e5e5e;padding:.5em"><p style=font-style:italic;padding:none><p>Both cooperative scheduling and pre-emptive scheduling solved this particular issue. As its name suggests, cooperative scheduling required the process to <em>cooperate</em> and give up the CPU when it has no work to do. Pre-emptive scheduling improved on this by kicking the process out after a certain time or after an I/O bound call, like our above example.</p></p></div><p>The fundamental difference between our examples here is the CPU&rsquo;s utilization. A higher utilization in the non-blocking example means we can have a shorter runtime. The more we&rsquo;re utilizing the CPU the faster we can accomplish our tasks.</p><h2 id=reacts-blocking-calls class=anchor-link><a href=#reacts-blocking-calls>React&rsquo;s Blocking Calls</a></h2><p>In React v17 and before, rendering calls wereblocking, just like our I/O calls above. While React was rendering your component it could do nothing else. Again, just like I/O calls, a click or other activities were held up by the render.</p><p>Let&rsquo;s first look at how replacing the blocking call with a concurrent one can increase performance. We&rsquo;ll focus on responsiveness later. Using an API call as an example, we&rsquo;ll show how pre-rendering a bit of the page can reduce overall wait times for your user.</p><img alt="Rendering a skeleton on React 18 can be faster" src=api.png width=66%><p>Here we have our 3 tasks.</p><ol><li>Load the page and fetch our data</li><li>Render a skeleton of the page</li><li>Render the data of the page</li></ol><p>React 18 limits its idle time by rendering a skeleton into memory while waiting for the data. React 17 has to wait until the API call is over to begin rendering the skeleton. This leads to a faster load time after the data has returned which in turn means your page will load faster overall.</p><div style="margin-left:10%;margin-bottom:1em;background:#f0f0f0;border-left:2px solid #5e5e5e;padding:.5em"><p style=font-style:italic;padding:none><p>There are two other benefits with concurrently rendering this page.</p><ol><li>React v18 can keep displaying a loading screen longer while rendering in memory, then switch to a fully loaded page.</li><li>Partially rendered pages can be interrupted when data is refreshed. Before, React would render your stale components, see the new data, then re-render your components.</li></ol></p></div><h2 id=increasing-responsiveness class=anchor-link><a href=#increasing-responsiveness>Increasing Responsiveness</a></h2><p>Operating Systems and React face incredibly similar problems with responsiveness and blocking tasks. They both have a set of tasks with varying runtimes, priorities, and I/O usage. A worst-case scenario is your CPU kicking off a blocking I/O call right as you click on a button. Or in React, a blocking render starting as you click a button. Your button press seems to take ages while the background task holds the CPU hostage. With interruption, the CPU can be reprioritzed to process the button animation and your click.</p><img alt="A click event can be handled sooner and increase responsiveness" src=click.png width=66%><p>Even though the overall rendering time is not decreased, the latency (measured as time from interaction to response) is decreased.</p><p>In React, this could be buffering re-renders on an input field change, or a search button responding while the results populate on screen. These rendering changes won&rsquo;t block each other and will render in order of priority, giving the user a better experience.</p><h2 id=in-conclusion class=anchor-link><a href=#in-conclusion>In Conclusion</a></h2><p>Similar to how Operating Systems used multithreading on single processor systems to remove the effects of blocking I/O calls, the React team has used increased concurrency to reduce the effect of blocking rendering calls, resulting in faster execution and a better user experience. There&rsquo;s only one downside, added code complexity! Hopefully for most of us, this can be abstracted away into routers and component libraries.</p><p>Thanks for reading, and if you liked this post, you might want to read my&mldr; oh this is my first blog post. Well, come back soon I guess!</p></div><div class=container><hr></div><div class="container has-text-centered top-pad"><a href=#top><i class="fa fa-arrow-up"></i></a></div><div class=container><hr></div><div class=section id=footer><div class="container has-text-centered"><span class=footer-text><a href=https://github.com/victoriadrake/hugo-theme-introduction/><strong>Introduction</strong></a> theme for <a href=http://gohugo.io/>Hugo</a>. Made with <a href=https://victoria.dev><i class="fa fa-heart"></i> and <i class="fa fa-coffee"></i></a> by open source contributors.</span></div></div></div></section><script src=https://ryanlmahan.com/js/bundle.5c23c0437f001a469ca373a465a6f7487203d18e10cdff76d86a60af66d5ee28.js integrity="sha256-XCPAQ38AGkaco3OkZab3SHID0Y4Qzf922Gpgr2bV7ig="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KNZB2ZFE3S"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KNZB2ZFE3S")</script></body></html>